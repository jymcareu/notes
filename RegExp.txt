正则表达式

字符	匹配

[...]	方括号内的任何字符
[^...]	不在方括号内的任意字符
.	除换行符和其他Unicode行终止符之外的任意字符
\w	[a-zA-Z0-9]
\W	[^a-zA-Z0-9]
\s	空白符
\S	非空白符的字符
\d	[0-9]
\D	[^0-9]
[\b]	退格直接量



字符	含义

|	选择，匹配的是该符号左边的子表达式或右边的子表达式
(...)	组合，将几个项组合为一个单元，可以使用"*"、"+"、"？"、"|"等
	符号加以修饰，可供此后的引用使用
(?:...)	只组合，不能被引用
\n	和第n个分组相匹配，组引号是从左到右的括号数，从1开始。
(?=p)	在"(?="和")"之间加入一个表达式,用以说明括号内的表达式必须正确匹配,零宽正向先行断言，要求接下来的字符都与p匹配
(?!p)	零宽负向先行断言，要求接下来的字符不与p匹配。
\b	匹配一个单词的边界
\B	匹配非单词边界的位置
i	执行不区分大小写的匹配
g	执行一个全局匹配，简言之，即找到所有的匹配，而不是在找到第一个之后就停止
m	多行匹配


用\d可以匹配一个数字，\w可以匹配一个字母或数字；
.可以匹配任意字符；
用*表示任意个字符（包括0个），用+表示至少一个字符，用?表示0个或1个字符，用{n}表示n个字符，用{n,m}表示n-m个字符；
\s可以匹配一个空格，\S匹配的是非Unicode空白符的字符。\s+表示至少有一个空格，例如匹配' '，'\t\t'；


要做更精确地匹配，可以用[]表示范围：
    [0-9a-zA-Z\_]可以匹配一个数字、字母或者下划线；

    [0-9a-zA-Z\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串，比如'a100'，'0_Z'，'js2015'等等；

    [a-zA-Z\_\$][0-9a-zA-Z\_\$]*可以匹配由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串，也就是JavaScript允许的变量名；

    [a-zA-Z\_\$][0-9a-zA-Z\_\$]{0, 19}更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。
  
    A|B可以匹配A或B，所以(J|j)ava(S|s)cript可以匹配'JavaScript'、'Javascript'、'javaScript'或者'javascript'。

   ^表示行的开头，^\d表示必须以数字开头。

   $表示行的结束，\d$表示必须以数字结束。




String支持4种使用正则表达式的方法：

search():它的参数是一个正则表达式，返回第一个与之匹配的子串的起始位置，如果找不到，将返回-1。
"JavaScript".search(/script/i);  //4

replace():用来执行检索和替换操作。而且如果在替换字符串中出现$加数字，那么replace()将用与指定的子表达式相匹配的文本来替换这两个字符。
text.replace(/javascript/gi,"JavaScript");  //将所有不区分大小写的javascript都替换成大小写正确的JavaScript
var quote = /"([^"]*)"/g ;
text.replace(quote,'“$1”'); //用中文半角引号替换英文引号，同时要保持引号之间的内容（存储在$1中）没有被修改

match()：返回的是一个由匹配结果组成的数组。如果正则表达式设置了修饰符g,则该方法返回的数组包含字符串中的所有匹配结果。
"1 plus 2 equals 3".match(/\d+/g)  //["1","2","3"]

split():将调用它的字符串拆分成一个子串组成的数组，使用的分隔符是split的参数。
"1,2,3,4,5".split(/\,/);


var text = 'testing: 1, 2, 3';
var pattern = /\d+/g;
pattern.test(text);  //true,匹配成功
text.search(pattern);  //9，首次匹配成功的位置
text.match(pattern);  //["1","2","3"],所有匹配组成的数组
text.replace(pattern,'#'); //"testing: #, #, #"
text.splite(/\D+/); ["","1","2","3"]，用非数字字符截取字符串

JavaScript有两种方式创建一个正则表达式：第一种方式是直接通过/正则表达式/写出来，第二种方式是通过new RegExp('正则表达式')创建一个RegExp对象。
var re1 = /ABC\-001/;
var re2 = new RegExp('ABC\\-001');

RegExp对象的test()方法用于测试给定的字符串是否符合条件。
var re = /^\d{3}\-\d{3,8}$/;
re.test('010-12345'); // true
re.test('010-1234x'); // false
re.test('010 12345'); // false

切分字符串

用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码：

'a b   c'.split(' '); // ['a', 'b', '', '', 'c']

嗯，无法识别连续的空格，用正则表达式试试：

'a b   c'.split(/\s+/); // ['a', 'b', 'c']

无论多少个空格都可以正常分割。加入,试试：

'a,b, c  d'.split(/[\s\,]+/); // ['a', 'b', 'c', 'd']

再加入;试试：

'a,b;; c  d'.split(/[\s\,\;]+/); // ['a', 'b', 'c', 'd']

除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。比如：
^(\d{3})-(\d{3,8})$分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：
var re = /^(\d{3})-(\d{3,8})$/;
re.exec('010-12345'); // ['010-12345', '010', '12345']
re.exec('010 12345'); // null
exec()方法在匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。

正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0：
var re = /^(\d+)(0*)$/;
re.exec('102300'); // ['102300', '102300', '']
由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。
必须让\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\d+采用非贪婪匹配：
var re = /^(\d+?)(0*)$/;
re.exec('102300'); // ['102300', '1023', '00']

全局搜索：
JavaScript的正则表达式还有几个特殊的标志，最常用的是g，表示全局匹配；

全局匹配可以多次执行exec()方法来搜索一个匹配的字符串。当我们指定g标志后，每次运行exec()，正则表达式本身会更新lastIndex属性，表示上次匹配到的最后索引：
var s = 'JavaScript, VBScript, JScript and ECMAScript';
var re=/[a-zA-Z]+Script/g;

re.exec(s); // ['JavaScript']
re.lastIndex; // 10

re.exec(s); // ['VBScript']
re.lastIndex; // 20

re.exec(s); // ['JScript']
re.lastIndex; // 29

re.exec(s); // ['ECMAScript']
re.lastIndex; // 44

re.exec(s); // null，直到结束仍没有匹配到

全局匹配类似搜索，因此不能使用/^...$/，那样只会最多匹配一次。

正则表达式还可以指定i标志，表示忽略大小写，m标志，表示执行多行匹配。


RegExp()构造函数带有两个字符串参数，第一个参数是正则表达式的主体部分（即正则表达式直接量中两条斜线之间的文本），必须将'\'替换成'\\'。其中第二个参数可选，只能传入修饰符g、i、m或者它们的组合。

